#!/bin/bash
#=================================================================================
# System Vulnerability Scanner
# 
# Purpose: Scan Linux systems for:
#   - System information gathering
#   - Hardware bug detection
#   - Software vulnerability assessment
#   - CVE checking based on OS and packages
#
# Usage: sudo ./system_vulnerability_scanner.sh [options]
#
# Options:
#   -h, --help     Display this help message
#   -f, --full     Run a full scan (more comprehensive but slower)
#   -q, --quiet    Minimal output
#
# Author: Security Script Generator
# Date: $(date +%Y-%m-%d)
#=================================================================================

# Check if running as root
if [ "$EUID" -ne 0 ]; then
  echo "This script must be run as root. Try using sudo."
  exit 1
fi

#=================================================================================
# Color Definitions
#=================================================================================
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[0;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

#=================================================================================
# Helper Functions
#=================================================================================
print_banner() {
  echo -e "${BOLD}${BLUE}"
  echo "╔═══════════════════════════════════════════════════════════════╗"
  echo "║                 SYSTEM VULNERABILITY SCANNER                   ║"
  echo "╚═══════════════════════════════════════════════════════════════╝"
  echo -e "${NC}"
}

print_section() {
  echo -e "\n${BOLD}${CYAN}[+] $1 ${NC}\n"
  echo -e "${CYAN}=================================================${NC}"
}

print_subsection() {
  echo -e "\n${BOLD}${BLUE}[*] $1 ${NC}"
}

print_info() {
  echo -e "${WHITE}[INFO] $1${NC}"
}

print_success() {
  echo -e "${GREEN}[✓] $1${NC}"
}

print_warning() {
  echo -e "${YELLOW}[!] $1${NC}"
}

print_error() {
  echo -e "${RED}[✗] $1${NC}"
}

# Check if a command exists
command_exists() {
  command -v "$1" &> /dev/null
}

# Function to handle errors
handle_error() {
  local exit_code=$?
  local line_no=$1
  if [ $exit_code -ne 0 ]; then
    print_error "Error on line $line_no: Command exited with status $exit_code"
  fi
}

# Trap errors
trap 'handle_error $LINENO' ERR

# Check for required tools and install them if needed
check_dependencies() {
  print_subsection "Checking Dependencies"
  
  local dependencies=("curl" "wget" "lshw" "dmidecode" "smartmontools" "net-tools" "jq")
  local missing_deps=()
  
  for dep in "${dependencies[@]}"; do
    if ! command_exists "$dep"; then
      missing_deps+=("$dep")
      print_warning "$dep is not installed."
    else
      print_info "$dep is installed."
    fi
  done
  
  if [ ${#missing_deps[@]} -gt 0 ]; then
    print_warning "Some dependencies are missing. Attempting to install..."
    
    if command_exists apt-get; then
      apt-get update && apt-get install -y "${missing_deps[@]}"
    elif command_exists yum; then
      yum install -y "${missing_deps[@]}"
    elif command_exists dnf; then
      dnf install -y "${missing_deps[@]}"
    elif command_exists pacman; then
      pacman -S --noconfirm "${missing_deps[@]}"
    else
      print_error "Could not install dependencies. Please install them manually: ${missing_deps[*]}"
      return 1
    fi
    
    print_success "Dependencies installed."
  else
    print_success "All dependencies are installed."
  fi
}

#=================================================================================
# System Information Gathering
#=================================================================================
gather_system_info() {
  print_section "Gathering System Information"
  
  # OS Information
  print_subsection "Operating System Information"
  if [ -f /etc/os-release ]; then
    source /etc/os-release
    OS_NAME="$NAME"
    OS_VERSION="$VERSION_ID"
    OS_ID="$ID"
    print_info "OS: $OS_NAME"
    print_info "Version: $OS_VERSION"
    print_info "ID: $OS_ID"
  else
    OS_NAME=$(uname -s)
    OS_VERSION=$(uname -r)
    print_info "OS: $OS_NAME"
    print_info "Version: $OS_VERSION"
  fi
  
  # Kernel Information
  print_subsection "Kernel Information"
  KERNEL_VERSION=$(uname -r)
  KERNEL_ARCH=$(uname -m)
  print_info "Kernel Version: $KERNEL_VERSION"
  print_info "Architecture: $KERNEL_ARCH"
  
  # Hardware Information
  print_subsection "Hardware Information"
  if command_exists lshw; then
    echo -e "${WHITE}"
    CPU_INFO=$(lshw -class processor -short 2>/dev/null | grep -v "WARNING")
    print_info "CPU Information:"
    echo "$CPU_INFO" | sed 's/^/  /'
    
    MEMORY_INFO=$(lshw -class memory -short 2>/dev/null | grep -v "WARNING")
    print_info "Memory Information:"
    echo "$MEMORY_INFO" | sed 's/^/  /'
    echo -e "${NC}"
  else
    CPU_INFO=$(grep "model name" /proc/cpuinfo | head -1 | cut -d':' -f2 | sed 's/^[ \t]*//')
    MEMORY_INFO=$(grep MemTotal /proc/meminfo | awk '{print $2/1024/1024 " GB"}')
    print_info "CPU: $CPU_INFO"
    print_info "Memory: $MEMORY_INFO"
  fi
  
  # Disk Information
  print_subsection "Disk Information"
  echo -e "${WHITE}"
  df -h | grep -v "tmpfs" | grep -v "udev"
  echo -e "${NC}"
  
  # Network Information
  print_subsection "Network Information"
  echo -e "${WHITE}"
  if command_exists ip; then
    ip addr | grep -E "inet |inet6 " | grep -v "127.0.0.1" | grep -v "::1"
  elif command_exists ifconfig; then
    ifconfig | grep -E "inet |inet6 " | grep -v "127.0.0.1" | grep -v "::1"
  fi
  echo -e "${NC}"
  
  # Installed Package Information
  print_subsection "Installed Packages"
  if command_exists apt; then
    PKG_COUNT=$(apt list --installed 2>/dev/null | wc -l)
    PKG_MANAGER="apt (Debian/Ubuntu)"
  elif command_exists dpkg; then
    PKG_COUNT=$(dpkg -l | grep "^ii" | wc -l)
    PKG_MANAGER="dpkg (Debian/Ubuntu)"
  elif command_exists rpm; then
    PKG_COUNT=$(rpm -qa | wc -l)
    PKG_MANAGER="rpm (RedHat/Fedora/CentOS)"
  elif command_exists yum; then
    PKG_COUNT=$(yum list installed | wc -l)
    PKG_MANAGER="yum (RedHat/Fedora/CentOS)"
  elif command_exists dnf; then
    PKG_COUNT=$(dnf list installed | wc -l)
    PKG_MANAGER="dnf (Fedora)"
  elif command_exists pacman; then
    PKG_COUNT=$(pacman -Q | wc -l)
    PKG_MANAGER="pacman (Arch)"
  else
    PKG_COUNT="Unknown"
    PKG_MANAGER="Unknown"
  fi
  print_info "Package Manager: $PKG_MANAGER"
  print_info "Installed Packages: $PKG_COUNT"
  
  # Web Server Detection
  print_subsection "Web Server Detection"
  if command_exists apache2 || command_exists httpd; then
    if command_exists apache2; then
      WEB_SERVER="Apache $(apache2 -v | grep "Server version" | cut -d/ -f2 | awk '{print $1}')"
    else
      WEB_SERVER="Apache $(httpd -v | grep "Server version" | cut -d/ -f2 | awk '{print $1}')"
    fi
    print_info "Web Server: $WEB_SERVER"
    APACHE_MODULES=$(apache2ctl -M 2>/dev/null || httpd -M 2>/dev/null)
    print_info "Loaded Modules:"
    echo -e "${WHITE}$APACHE_MODULES${NC}" | grep -v "Loaded" | sed 's/^/  /'
  elif command_exists nginx; then
    WEB_SERVER="Nginx $(nginx -v 2>&1 | cut -d/ -f2)"
    print_info "Web Server: $WEB_SERVER"
  else
    print_info "No common web server detected"
  fi
  
  # Running Services
  print_subsection "Running Services"
  if command_exists systemctl; then
    RUNNING_SERVICES=$(systemctl list-units --type=service --state=running | grep .service | wc -l)
    print_info "Running Services (systemd): $RUNNING_SERVICES"
  elif [ -d /etc/init.d ]; then
    RUNNING_SERVICES=$(find /etc/init.d -type f -executable | wc -l)
    print_info "Init Scripts: $RUNNING_SERVICES"
  fi
  
  # Save system information for later use
  SYSTEM_INFO_FILE="/tmp/system_info_$$.tmp"
  cat > "$SYSTEM_INFO_FILE" << EOF
OS_NAME="$OS_NAME"
OS_VERSION="$OS_VERSION"
OS_ID="$OS_ID"
KERNEL_VERSION="$KERNEL_VERSION"
KERNEL_ARCH="$KERNEL_ARCH"
EOF
  # Save basic system information for package analysis
  if command_exists dpkg; then
    dpkg -l | grep -E "^ii" > "/tmp/installed_packages_$$.tmp"
  elif command_exists rpm; then
    rpm -qa > "/tmp/installed_packages_$$.tmp"
  elif command_exists pacman; then
    pacman -Q > "/tmp/installed_packages_$$.tmp"
  fi
}

#=================================================================================
# Hardware Monitoring
#=================================================================================
check_hardware() {
  print_section "Hardware Monitoring"
  
  # Check for hardware bugs or issues
  print_subsection "Hardware Diagnostics"
  
  # CPU Vulnerabilities
  print_info "Checking CPU Vulnerabilities"
  if [ -d /sys/devices/system/cpu/vulnerabilities ]; then
    echo -e "${WHITE}"
    for vuln in /sys/devices/system/cpu/vulnerabilities/*; do
      VULN_NAME=$(basename "$vuln")
      VULN_STATUS=$(cat "$vuln")
      if [[ "$VULN_STATUS" == *"vulnerable"* ]] || [[ "$VULN_STATUS" == *"Vulnerable"* ]]; then
        echo -e "${RED}[VULNERABLE] $VULN_NAME: $VULN_STATUS${NC}"
      elif [[ "$VULN_STATUS" == *"mitigation"* ]] || [[ "$VULN_STATUS" == *"Mitigation"* ]]; then
        echo -e "${YELLOW}[MITIGATED] $VULN_NAME: $VULN_STATUS${NC}"
      else
        echo -e "${GREEN}[PROTECTED] $VULN_NAME: $VULN_STATUS${NC}"
      fi
    done
    echo -e "${NC}"
  else
    print_warning "CPU vulnerability information not available"
  fi
  
  # Check temperature
  print_info "Checking System Temperature"
  if command_exists sensors; then
    echo -e "${WHITE}"
    sensors | grep -E "°C|°F"
    echo -e "${NC}"
  else
    if [ -d /sys/class/thermal ]; then
      for thermal in /sys/class/thermal/thermal_zone*/temp; do
        if [ -f "$thermal" ]; then
          ZONE=$(basename "$(dirname "$thermal")")
          TEMP=$(cat "$thermal")
          # Convert millidegrees to degrees
          TEMP_C=$(echo "scale=1; $TEMP/1000" | bc)
          echo -e "${WHITE}$ZONE: ${TEMP_C}°C${NC}"
        fi
      done
    else
      print_warning "Temperature information not available"
    fi
  fi
  
  # Check disk health
  print_subsection "Disk Health"
  if command_exists smartctl; then
    DISKS=$(lsblk -d -o NAME | grep -v NAME)
    for disk in $DISKS; do
      print_info "Checking disk /dev/$disk"
      SMART_INFO=$(smartctl -H /dev/"$disk" 2>/dev/null)
      if [[ $? -eq 0 ]]; then
        HEALTH_STATUS=$(echo "$SMART_INFO" | grep "SMART overall-health" | awk '{print $NF}')
        if [[ "$HEALTH_STATUS" == "PASSED" ]]; then
          print_success "SMART status: $HEALTH_STATUS"
        else
          print_error "SMART status: $HEALTH_STATUS"
          echo -e "${WHITE}$SMART_INFO${NC}" | sed 's/^/  /'
        fi
      else
        print_warning "Could not get SMART information for /dev/$disk"
      fi
    done
  else
    print_warning "smartctl not available, cannot check disk health"
  fi
  
  # Check memory errors
  print_subsection "Memory Diagnostics"
  if [ -f /var/log/kern.log ]; then
    MEM_ERRORS=$(grep -i "memory error" /var/log/kern.log | wc -l)
    if [ "$MEM_ERRORS" -gt 0 ]; then
      print_error "Found $MEM_ERRORS memory errors in kernel logs"
      grep -i "memory error" /var/log/kern.log | tail -5 | sed 's/^/  /'
    else
      print_success "No memory errors found in kernel logs"
    fi
  else
    print_warning "Kernel log not available at /var/log/kern.log"
  fi
}

#=================================================================================
# CVE Checking
#=================================================================================
check_cves() {
  print_section "CVE Vulnerability Checking"
  
  # Source the system info file
  if [ -f "$SYSTEM_INFO_FILE" ]; then
    source "$SYSTEM_INFO_FILE"
  else
    print_error "System information file not found. Run gather_system_info first."
    return 1
  fi
  
  print_subsection "Checking Known CVEs for $OS_NAME $OS_VERSION"
  
  # Function to handle API rate limiting with exponential backoff
  api_call_with_backoff() {
    local url="$1"
    local max_retries=5
    local retry_count=0
    local wait_time=5
    
    while [ $retry_count -lt $max_retries ]; do
      response=$(curl -s -w "\\n%{http_code}" "$url")
      http_code=$(echo "$response" | tail -n1)
      content=$(echo "$response" | sed '$d')
      
      if [ "$http_code" -eq 200 ]; then
        echo "$content"
        return 0
      elif [ "$http_code" -eq 429 ]; then
        print_warning "Rate limit hit, waiting ${wait_time}s before retry"
        sleep $wait_time
        retry_count=$((retry_count + 1))
        wait_time=$((wait_time * 2))  # Exponential backoff
      else
        print_error "API request failed with HTTP code $http_code"
        return 1
      fi
    done
    
    print_error "Max retries reached when calling API"
    return 1
  }
  
  # Check for kernel vulnerabilities
  print_info "Checking kernel vulnerabilities"
  
  # Format kernel version for API query
  KERNEL_VERSION_FORMATTED=$(echo "$KERNEL_VERSION" | cut -d '-' -f 1)
  
  # Use NVD API to query for kernel vulnerabilities
  if command_exists curl && command_exists jq; then
    # Create NVD API URL for kernel
    NVD_API_URL="https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=linux+kernel+${KERNEL_VERSION_FORMATTED}"
    
    print_info "Querying NVD database for kernel vulnerabilities..."
    NVD_RESPONSE=$(api_call_with_backoff "$NVD_API_URL")
    
    if [ $? -eq 0 ]; then
      # Extract CVEs using jq
      KERNEL_CVES=$(echo "$NVD_RESPONSE" | jq -r '.vulnerabilities[] | "\(.cve.id) - \(.cve.descriptions[0].value) - CVSS: \(.cve.metrics.cvssMetricV31[0].cvssData.baseScore)"' 2>/dev/null)
      
      if [ -n "$KERNEL_CVES" ]; then
        CVE_COUNT=$(echo "$KERNEL_CVES" | wc -l)
        print_warning "Found $CVE_COUNT potential kernel vulnerabilities"
        echo -e "${YELLOW}"
        echo "$KERNEL_CVES" | head -10 | sed 's/^/  /'
        if [ "$CVE_COUNT" -gt 10 ]; then
          print_info "Showing 10 of $CVE_COUNT vulnerabilities"
        fi
        echo -e "${NC}"
      else
        print_success "No known CVEs found for the current kernel version"
      fi
    else
      print_error "Failed to query NVD database"
    fi
  else
    print_warning "curl or jq not available, cannot check for CVEs online"
  fi
  
  # Check for distribution-specific vulnerabilities
  print_subsection "Distribution Security Advisories"
  
  case "$OS_ID" in
    ubuntu|debian)
      print_info "Checking for security updates (Debian/Ubuntu)"
      if command_exists apt; then
        # Update package lists
        apt-get update -qq
        
        # Check for security updates
        SECURITY_UPDATES=$(apt list --upgradable 2>/dev/null | grep -i security | wc -l)
        
        if [ "$SECURITY_UPDATES" -gt 0 ]; then
          print_warning "Found $SECURITY_UPDATES packages with security updates available"
          apt list --upgradable 2>/dev/null | grep -i security | head -10 | sed 's/^/  /'
        else
          print_success "No security updates pending"
        fi
      fi
      ;;
    centos|rhel|fedora)
      print_info "Checking for security updates (RHEL/CentOS/Fedora)"
      if command_exists yum; then
        SECURITY_UPDATES=$(yum updateinfo list security 2>/dev/null | grep -v "Loaded plugins" | wc -l)
        
        if [ "$SECURITY_UPDATES" -gt 0 ]; then
          print_warning "Found $SECURITY_UPDATES packages with security updates available"
          yum updateinfo list security 2>/dev/null | grep -v "Loaded plugins" | head -10 | sed 's/^/  /'
        else
          print_success "No security updates pending"
        fi
      fi
      ;;
    *)
      print_warning "Security update check not implemented for $OS_ID"
      ;;
  esac
  
  # Check for package-specific vulnerabilities
  print_subsection "Package Vulnerability Analysis"
  
  if [ -f "/tmp/installed_packages_$$.tmp" ]; then
    # Select critical packages to check for CVEs
    CRITICAL_PACKAGES=("openssl" "openssh" "bash" "sudo" "nginx" "apache" "httpd" "mariadb" "mysql" "postgresql" "php" "python")
    
    for pkg in "${CRITICAL_PACKAGES[@]}"; do
      PKG_INFO=$(grep -i "$pkg" "/tmp/installed_packages_$$.tmp" | head -1)
      
      if [ -n "$PKG_INFO" ]; then
        # Extract package version
        if command_exists dpkg; then
          PKG_NAME=$(echo "$PKG_INFO" | awk '{print $2}')
          PKG_VERSION=$(echo "$PKG_INFO" | awk '{print $3}')
        elif command_exists rpm; then
          PKG_NAME=$(echo "$PKG_INFO" | cut -d'-' -f1)
          PKG_VERSION=$(echo "$PKG_INFO" | cut -d'-' -f2)
        else
          PKG_NAME=$pkg
          PKG_VERSION="unknown"
        fi
        
        if [ "$PKG_VERSION" != "unknown" ]; then
          print_info "Checking $PKG_NAME ($PKG_VERSION) for known vulnerabilities"
          
          # Query NVD for this package version
          NVD_API_URL="https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${PKG_NAME}+${PKG_VERSION}"
          
          NVD_RESPONSE=$(api_call_with_backoff "$NVD_API_URL")
          
          
            PKG_CVES=$(echo "$NVD_RESPONSE" | jq -r '.vulnerabilities[] | "\(.cve.id) - \(.cve.descriptions[0].value) - CVSS: \(.cve.metrics.cvssMetricV31[0].cvssData.baseScore // "N/A")"' 2>/dev/null)
            
            if [ -n "$PKG_CVES" ]; then
              PKG_CVE_COUNT=$(echo "$PKG_CVES" | wc -l)
              print_warning "Found $PKG_CVE_COUNT potential vulnerabilities for $PKG_NAME"
              echo -e "${YELLOW}"
              echo "$PKG_CVES" | head -5 | sed 's/^/  /'
              if [ "$PKG_CVE_COUNT" -gt 5 ]; then
                print_info "Showing 5 of $PKG_CVE_COUNT vulnerabilities"
              fi
              echo -e "${NC}"
            else
              print_success "No known CVEs found for $PKG_NAME ($PKG_VERSION)"
            fi
          else
            print_error "Failed to query NVD database for $PKG_NAME"
          fi
        fi
      fi
    done
  else
    print_warning "Package information file not found"
  fi
}

#=================================================================================
# Web Application Vulnerability Scanning
#=================================================================================
check_web_vulnerabilities() {
  print_section "Web Application Vulnerability Scanning"
  
  # Check if web server is running
  WEB_SERVER_RUNNING=false
  
  if command_exists netstat || command_exists ss; then
    print_subsection "Detecting Web Servers"
    
    # Check for common web server ports
    if command_exists netstat; then
      WEB_PORTS=$(netstat -tuln | grep -E ':80|:443|:8080|:8443|:3000|:8000|:8008|:8888' | grep 'LISTEN')
    else
      WEB_PORTS=$(ss -tuln | grep -E ':80|:443|:8080|:8443|:3000|:8000|:8008|:8888' | grep 'LISTEN')
    fi
    
    if [ -n "$WEB_PORTS" ]; then
      WEB_SERVER_RUNNING=true
      print_info "Web server ports detected:"
      echo -e "${WHITE}$WEB_PORTS${NC}" | sed 's/^/  /'
    else
      print_info "No web server ports detected"
    fi
  fi
  
  # Web Application Framework Detection
  if [ "$WEB_SERVER_RUNNING" = true ]; then
    print_subsection "Web Application Framework Detection"
    
    # Common web application directories to check
    WEB_DIRS=("/var/www/html" "/var/www" "/usr/share/nginx/html" "/srv/http" "/srv/www")
    
    for dir in "${WEB_DIRS[@]}"; do
      if [ -d "$dir" ]; then
        print_info "Checking web directory: $dir"
        
        # Check for common frameworks
        if [ -f "$dir/wp-config.php" ] || [ -d "$dir/wp-content" ]; then
          print_info "WordPress detected"
          if [ -f "$dir/wp-includes/version.php" ]; then
            WP_VERSION=$(grep '\$wp_version' "$dir/wp-includes/version.php" | cut -d "'" -f 2)
            print_info "WordPress version: $WP_VERSION"
            
            # Check WordPress version against known vulnerabilities
            if command_exists curl && command_exists jq; then
              print_info "Checking WordPress version for vulnerabilities"
              WP_API_URL="https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=wordpress+${WP_VERSION}"
              
              WP_VULNS=$(api_call_with_backoff "$WP_API_URL")
              if [ $? -eq 0 ]; then
                WP_CVES=$(echo "$WP_VULNS" | jq -r '.vulnerabilities[] | "\(.cve.id) - \(.cve.descriptions[0].value) - CVSS: \(.cve.metrics.cvssMetricV31[0].cvssData.baseScore // "N/A")"' 2>/dev/null)
                
                if [ -n "$WP_CVES" ]; then
                  WP_CVE_COUNT=$(echo "$WP_CVES" | wc -l)
                  print_warning "Found $WP_CVE_COUNT potential vulnerabilities for WordPress $WP_VERSION"
                  echo -e "${YELLOW}"
                  echo "$WP_CVES" | head -5 | sed 's/^/  /'
                  echo -e "${NC}"
                else
                  print_success "No known vulnerabilities for WordPress $WP_VERSION"
                fi
              fi
            fi
            
            # Check WordPress plugins
            if [ -d "$dir/wp-content/plugins" ]; then
              print_info "Scanning WordPress plugins"
              for plugin_dir in "$dir/wp-content/plugins"/*; do
                if [ -d "$plugin_dir" ]; then
                  PLUGIN_NAME=$(basename "$plugin_dir")
                  
                  # Try to get plugin version
                  PLUGIN_VERSION="unknown"
                  for file in "$plugin_dir"/*.php; do
                    if [ -f "$file" ]; then
                      VERSION_LINE=$(grep -i "Version:" "$file" | head -1)
                      if [ -n "$VERSION_LINE" ]; then
                        PLUGIN_VERSION=$(echo "$VERSION_LINE" | sed 's/.*Version: *\([0-9.]*\).*/\1/')
                        break
                      fi
                    fi
                  done
                  
                  print_info "Plugin: $PLUGIN_NAME, Version: $PLUGIN_VERSION"
                  
                  # Check for vulnerable plugins
                  if [ "$PLUGIN_VERSION" != "unknown" ] && command_exists curl && command_exists jq; then
                    PLUGIN_API_URL="https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=wordpress+plugin+${PLUGIN_NAME}+${PLUGIN_VERSION}"
                    
                    PLUGIN_VULNS=$(api_call_with_backoff "$PLUGIN_API_URL")
                    if [ $? -eq 0 ]; then
                      PLUGIN_CVES=$(echo "$PLUGIN_VULNS" | jq -r '.vulnerabilities[] | "\(.cve.id) - \(.cve.descriptions[0].value) - CVSS: \(.cve.metrics.cvssMetricV31[0].cvssData.baseScore // "N/A")"' 2>/dev/null)
                      
                      if [ -n "$PLUGIN_CVES" ]; then
                        print_warning "Found vulnerabilities for plugin $PLUGIN_NAME"
                        echo -e "${YELLOW}"
                        echo "$PLUGIN_CVES" | head -3 | sed 's/^/  /'
                        echo -e "${NC}"
                      fi
                    fi
                  fi
                fi
              done
            fi
          fi
        elif [ -f "$dir/configuration.php" ] && grep -q "JConfig" "$dir/configuration.php"; then
          print_info "Joomla detected"
          # Try to determine Joomla version
          if [ -f "$dir/libraries/cms/version/version.php" ]; then
            JOOMLA_VERSION=$(grep -E "RELEASE|DEV_LEVEL" "$dir/libraries/cms/version/version.php" | awk -F "'" '{print $2}' | tr '\n' '.' | sed 's/\.$//')
            print_info "Joomla version: $JOOMLA_VERSION"
          elif [ -f "$dir/libraries/src/Version.php" ]; then
            JOOMLA_VERSION=$(grep -E "RELEASE|DEV_LEVEL" "$dir/libraries/src/Version.php" | awk -F "'" '{print $2}' | tr '\n' '.' | sed 's/\.$//')
            print_info "Joomla version: $JOOMLA_VERSION"
          fi
        elif [ -f "$dir/index.php" ] && [ -d "$dir/modules" ] && [ -d "$dir/themes" ]; then
          if grep -q "Drupal" "$dir/index.php"; then
            print_info "Drupal detected"
            # Try to determine Drupal version
            if [ -f "$dir/core/lib/Drupal.php" ]; then
              DRUPAL_VERSION=$(grep "const VERSION" "$dir/core/lib/Drupal.php" | cut -d "'" -f 2)
              print_info "Drupal version: $DRUPAL_VERSION"
            fi
          fi
        elif [ -f "$dir/app/etc/config.xml" ] || [ -f "$dir/app/Mage.php" ]; then
          print_info "Magento detected"
          # Try to determine Magento version
          if [ -f "$dir/app/Mage.php" ]; then
            MAGENTO_VERSION=$(grep "'Mage_Version'" "$dir/app/Mage.php" | cut -d "'" -f 4)
            print_info "Magento version: $MAGENTO_VERSION"
          fi
        elif [ -f "$dir/config/config.php" ] && grep -q "Laravel" "$dir/config/app.php" 2>/dev/null; then
          print_info "Laravel detected"
        elif [ -d "$dir/wp-admin" ]; then
          print_info "WordPress detected (directory structure)"
        elif [ -d "$dir/administrator" ] && [ -d "$dir/components" ]; then
          print_info "Joomla detected (directory structure)"
        fi
      fi
    done
  else
    print_info "No web server detected, skipping web application framework detection"
  fi
  
  # Web Server Configuration Check
  print_subsection "Web Server Configuration Check"
  
  # Check Apache configuration if installed
  if command_exists apache2 || command_exists httpd; then
    print_info "Checking Apache configuration"
    
    # Determine Apache config path
    if command_exists apache2; then
      APACHE_PATH="/etc/apache2"
      APACHE_BIN="apache2"
    else
      APACHE_PATH="/etc/httpd"
      APACHE_BIN="httpd"
    fi
    
    # Check for SSL configuration
    if [ -d "$APACHE_PATH/sites-enabled" ]; then
      SSL_CONFIGS=$(grep -l "SSLEngine on" $APACHE_PATH/sites-enabled/*)
      if [ -n "$SSL_CONFIGS" ]; then
        print_info "SSL is enabled in these virtual hosts:"
        echo -e "${WHITE}$SSL_CONFIGS${NC}" | sed 's/^/  /'
        
        # Check SSL protocol and cipher configuration
        for config in $SSL_CONFIGS; do
          SSL_PROTOCOL=$(grep "SSLProtocol" "$config")
          SSL_CIPHER=$(grep "SSLCipherSuite" "$config")
          
          if [[ "$SSL_PROTOCOL" == *"SSLv2"* ]] || [[ "$SSL_PROTOCOL" == *"SSLv3"* ]]; then
            print_warning "Insecure SSL protocol configured in $config:"
            echo -e "${YELLOW}  $SSL_PROTOCOL${NC}"
          fi
          
          if [[ "$SSL_CIPHER" == *"RC4"* ]] || [[ "$SSL_CIPHER" == *"DES"* ]] || [[ "$SSL_CIPHER" == *"MD5"* ]]; then
            print_warning "Insecure SSL ciphers configured in $config:"
            echo -e "${YELLOW}  $SSL_CIPHER${NC}"
          fi
        done
      else
        print_warning "SSL is not enabled in any Apache virtual host"
      fi
    elif [ -f "$APACHE_PATH/conf/httpd.conf" ]; then
      # Check main config file for SSL
      if grep -q "SSLEngine on" "$APACHE_PATH/conf/httpd.conf"; then
        print_info "SSL is enabled in httpd.conf"
        
        # Check SSL protocol and cipher configuration
        SSL_PROTOCOL=$(grep "SSLProtocol" "$APACHE_PATH/conf/httpd.conf")
        SSL_CIPHER=$(grep "SSLCipherSuite" "$APACHE_PATH/conf/httpd.conf")
        
        if [[ "$SSL_PROTOCOL" == *"SSLv2"* ]] || [[ "$SSL_PROTOCOL" == *"SSLv3"* ]]; then
          print_warning "Insecure SSL protocol configured:"
          echo -e "${YELLOW}  $SSL_PROTOCOL${NC}"
        fi
        
        if [[ "$SSL_CIPHER" == *"RC4"* ]] || [[ "$SSL_CIPHER" == *"DES"* ]] || [[ "$SSL_CIPHER" == *"MD5"* ]]; then
          print_warning "Insecure SSL ciphers configured:"
          echo -e "${YELLOW}  $SSL_CIPHER${NC}"
        fi
      else
        print_warning "SSL is not enabled in Apache configuration"
      fi
    fi
    
    # Check for directory listing
    DIRECTORY_LISTING=$(grep -r "Options" $APACHE_PATH | grep -i "Indexes")
    if [ -n "$DIRECTORY_LISTING" ]; then
      print_warning "Directory listing is enabled:"
      echo -e "${YELLOW}$DIRECTORY_LISTING${NC}" | sed 's/^/  /'
    else
      print_success "Directory listing is disabled"
    fi
    
    # Check for server signature
    SERVER_SIGNATURE=$(grep -r "ServerSignature" $APACHE_PATH)
    if [[ "$SERVER_SIGNATURE" == *"ServerSignature On"* ]]; then
      print_warning "Server signature is enabled, exposing server information"
    else
      print_success "Server signature is properly disabled"
    fi
    
    # Check for server tokens
    SERVER_TOKENS=$(grep -r "ServerTokens" $APACHE_PATH)
    if [[ "$SERVER_TOKENS" == *"ServerTokens Full"* ]] || [[ "$SERVER_TOKENS" == *"ServerTokens OS"* ]]; then
      print_warning "Server tokens setting reveals too much information about the server"
    elif [[ "$SERVER_TOKENS" == *"ServerTokens Prod"* ]]; then
      print_success "Server tokens properly configured to minimal information"
    fi
    
    # Check for HTTP methods
    LIMIT_METHOD=$(grep -r "LimitExcept" $APACHE_PATH)
    if [ -z "$LIMIT_METHOD" ]; then
      print_warning "No HTTP method restrictions found, potentially allowing unsafe methods"
      
      # Check if we can test HTTP methods
      if command_exists curl; then
        print_info "Testing HTTP methods on localhost..."
        
        # Get local web server hostname or IP
        LOCAL_HTTP=$(netstat -tlpn 2>/dev/null | grep -E ":80|:443" | head -1)
        if [ -n "$LOCAL_HTTP" ]; then
          HTTP_PORT=$(echo "$LOCAL_HTTP" | awk '{print $4}' | cut -d':' -f2)
          
          # Test for dangerous HTTP methods
          for method in PUT DELETE TRACE OPTIONS; do
            METHOD_RESULT=$(curl -s -X "$method" -I "http://localhost:$HTTP_PORT" 2>/dev/null | head -1)
            
            if [[ "$METHOD_RESULT" == *"200 OK"* ]] || [[ "$METHOD_RESULT" == *"204 No Content"* ]]; then
              print_error "HTTP method $method is enabled and accepting requests"
            elif [[ "$METHOD_RESULT" == *"405 Method Not Allowed"* ]]; then
              print_success "HTTP method $method is properly restricted"
            else
              print_info "HTTP method $method returned: $METHOD_RESULT"
            fi
          done
        else
          print_warning "Web server not listening on standard ports, skipping HTTP method test"
        fi
      fi
    else
      print_success "HTTP methods are properly restricted"
      echo -e "${GREEN}$LIMIT_METHOD${NC}" | sed 's/^/  /'
    fi
  print_subsection "Hardware Tampering Check"
  if command_exists dmidecode; then
    # Save current hardware fingerprint
    HARDWARE_FINGERPRINT="/tmp/hw_fingerprint_$$.tmp"
    dmidecode | grep -E "Manufacturer|Product Name|Serial Number" > "$HARDWARE_FINGERPRINT"
    
    # Check if we have a previous fingerprint to compare
    if [ -f /var/lib/hw_fingerprint.dat ]; then
      print_info "Comparing hardware fingerprint with previous state"
      if diff /var/lib/hw_fingerprint.dat "$HARDWARE_FINGERPRINT" > /dev/null; then
        print_success "No hardware changes detected"
      else
        print_warning "Hardware configuration has changed since last check"
        echo -e "${YELLOW}Differences:${NC}"
        diff --color=always /var/lib/hw_fingerprint.dat "$HARDWARE_FINGERPRINT" | grep -E "^[<>]" | sed 's/^/  /'
      fi
    else
      print_info "No previous hardware fingerprint found, creating baseline"
      # Create directory if it doesn't exist
      mkdir -p /var/lib
    fi
    
    # Update the fingerprint file
    cp "$HARDWARE_FINGERPRINT" /var/lib/hw_fingerprint.dat
    print_success "Hardware fingerprint updated"
    
    # Check for USB devices
    print_info "Checking USB devices"
    if [ -f /var/lib/usb_devices.dat ]; then
      USB_DEVICES_CURRENT="/tmp/usb_devices_$$.tmp"
      lsusb > "$USB_DEVICES_CURRENT"
      
      if diff /var/lib/usb_devices.dat "$USB_DEVICES_CURRENT" > /dev/null; then
        print_success "No USB device changes detected"
      else
        print_warning "USB device configuration has changed"
        echo -e "${YELLOW}New or changed USB devices:${NC}"
        diff /var/lib/usb_devices.dat "$USB_DEVICES_CURRENT" | grep -E "^[<>]" | sed 's/^/  /'
      fi
      
      # Update USB devices file
      cp "$USB_DEVICES_CURRENT" /var/lib/usb_devices.dat
    else
      lsusb > /var/lib/usb_devices.dat
      print_info "Created baseline USB device inventory"
    fi
    
    # Check for physical intrusion detection if available
    if [ -d /sys/devices/platform/chassis-event ]; then
      CHASSIS_INTRUSION=$(cat /sys/devices/platform/chassis-event/chassis* 2>/dev/null)
      if [ -n "$CHASSIS_INTRUSION" ] && [ "$CHASSIS_INTRUSION" != "0" ]; then
        print_error "Chassis intrusion detected! System case may have been opened."
      else
        print_success "No chassis intrusion detected"
      fi
    fi
  else
    print_warning "dmidecode not available, cannot check for hardware changes"
  fi
  
  # Check for Nginx configuration if installed
  if command_exists nginx; then
    print_info "Checking Nginx configuration"
    
    # Determine Nginx config path
    NGINX_PATH="/etc/nginx"
    
    # Check for SSL configuration
    if [ -d "$NGINX_PATH" ]; then
      SSL_CONFIGS=$(grep -l "ssl_certificate" $NGINX_PATH/sites-enabled/* 2>/dev/null || grep -l "ssl_certificate" $NGINX_PATH/conf.d/* 2>/dev/null)
      
      if [ -n "$SSL_CONFIGS" ]; then
        print_info "SSL is enabled in these virtual hosts:"
        echo -e "${WHITE}$SSL_CONFIGS${NC}" | sed 's/^/  /'
        
        # Check SSL protocol and cipher configuration
        for config in $SSL_CONFIGS; do
          SSL_PROTOCOL=$(grep "ssl_protocols" "$config")
          SSL_CIPHER=$(grep "ssl_ciphers" "$config")
          
          if [[ "$SSL_PROTOCOL" == *"SSLv2"* ]] || [[ "$SSL_PROTOCOL" == *"SSLv3"* ]] || [[ "$SSL_PROTOCOL" == *"TLSv1 "* ]]; then
            print_warning "Insecure SSL protocol configured in $config:"
            echo -e "${YELLOW}  $SSL_PROTOCOL${NC}"
          fi
          
          if [[ "$SSL_CIPHER" == *"RC4"* ]] || [[ "$SSL_CIPHER" == *"DES"* ]] || [[ "$SSL_CIPHER" == *"MD5"* ]]; then
            print_warning "Insecure SSL ciphers configured in $config:"
            echo -e "${YELLOW}  $SSL_CIPHER${NC}"
          fi
        done
      else
        print_warning "SSL configuration not found in Nginx virtual hosts"
      fi
      
      # Check for security headers
      SECURITY_HEADERS=$(grep -r "add_header" $NGINX_PATH)
      
      if [[ "$SECURITY_HEADERS" == *"X-Frame-Options"* ]]; then
        print_success "X-Frame-Options header configured"
      else
        print_warning "X-Frame-Options header not found - potential clickjacking risk"
      fi
      
      if [[ "$SECURITY_HEADERS" == *"X-Content-Type-Options"* ]]; then
        print_success "X-Content-Type-Options header configured"
      else
        print_warning "X-Content-Type-Options header not found - MIME sniffing risk"
      fi
      
      if [[ "$SECURITY_HEADERS" == *"X-XSS-Protection"* ]]; then
        print_success "X-XSS-Protection header configured"
      else
        print_warning "X-XSS-Protection header not found"
      fi
      
      # Check for server tokens
      SERVER_TOKENS=$(grep -r "server_tokens" $NGINX_PATH)
      if [[ "$SERVER_TOKENS" == *"server_tokens off"* ]]; then
        print_success "Server tokens are properly disabled"
      else
        print_warning "Server tokens not explicitly disabled, exposing server version information"
      fi
      
      # Check for directory listing
      if grep -r "autoindex on" $NGINX_PATH > /dev/null; then
        print_warning "Directory listing is enabled:"
        grep -r "autoindex on" $NGINX_PATH | sed 's/^/  /'
      else
        print_success "Directory listing is disabled"
      fi
    else
      print_warning "Nginx configuration directory not found at $NGINX_PATH"
    fi
  fi
  
  # Check for firmware/BIOS modifications
  if command_exists dmidecode; then
    print_info "Checking BIOS/UEFI information"
    BIOS_INFO=$(dmidecode -t bios)
    BIOS_VENDOR=$(echo "$BIOS_INFO" | grep -i "Vendor" | cut -d ":" -f 2 | sed 's/^ *//')
    BIOS_VERSION=$(echo "$BIOS_INFO" | grep -i "Version" | head -1 | cut -d ":" -f 2 | sed 's/^ *//')
    BIOS_DATE=$(echo "$BIOS_INFO" | grep -i "Release Date" | cut -d ":" -f 2 | sed 's/^ *//')
    
    print_info "BIOS Vendor: $BIOS_VENDOR"
    print_info "BIOS Version: $BIOS_VERSION"
    print_info "BIOS Date: $BIOS_DATE"
    
    # Check for known problematic or suspicious BIOS versions
    if [[ "$BIOS_VENDOR" == "Unknown" ]] || [[ "$BIOS_VERSION" == "Unknown" ]]; then
      print_warning "Unable to determine BIOS vendor or version - potential security concern"
    fi
  fi
}

#=================================================================================
#=================================================================================
# Cleanup Function
#=================================================================================
cleanup() {
  print_info "Cleaning up temporary files..."
  
  # List of temporary files to remove
  local temp_files=(
    "/tmp/system_info_$$.tmp"
    "/tmp/installed_packages_$$.tmp"
    "/tmp/hw_fingerprint_$$.tmp"
    "/tmp/usb_devices_$$.tmp"
  )
  
  # Remove temporary files
  for file in "${temp_files[@]}"; do
    if [ -f "$file" ]; then
      rm -f "$file"
      print_info "Removed $file"
    fi
  done
  
  print_success "Cleanup complete"
}

#=================================================================================
# Display Script Usage
#=================================================================================
usage() {
  echo "Usage: $0 [OPTIONS]"
  echo "System Vulnerability Scanner"
  echo ""
  echo "Options:"
  echo "  -h, --help     Display this help message"
  echo "  -f, --full     Run a full scan (more comprehensive but slower)"
  echo "  -q, --quiet    Minimal output"
  echo "  -w, --web      Focus on web server and application vulnerabilities"
  echo "  -s, --system   Focus on system vulnerabilities"
  echo "  -c, --cve      Focus on CVE checking"
  echo "  -n, --no-cleanup  Do not remove temporary files"
  echo ""
  echo "Examples:"
  echo "  $0 -f          Run a full comprehensive scan"
  echo "  $0 -w -c       Focus on web vulnerabilities and CVE checking"
  echo ""
  exit 1
}

#=================================================================================
# Main Execution
#=================================================================================

# Default settings
FULL_SCAN=false
QUIET_MODE=false
WEB_FOCUS=false
SYSTEM_FOCUS=false
CVE_FOCUS=false
DO_CLEANUP=true

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      usage
      ;;
    -f|--full)
      FULL_SCAN=true
      shift
      ;;
    -q|--quiet)
      QUIET_MODE=true
      shift
      ;;
    -w|--web)
      WEB_FOCUS=true
      shift
      ;;
    -s|--system)
      SYSTEM_FOCUS=true
      shift
      ;;
    -c|--cve)
      CVE_FOCUS=true
      shift
      ;;
    -n|--no-cleanup)
      DO_CLEANUP=false
      shift
      ;;
    *)
      echo "Unknown option: $1"
      usage
      ;;
  esac
done

# If no specific focus is set, enable all
if ! $WEB_FOCUS && ! $SYSTEM_FOCUS && ! $CVE_FOCUS; then
  WEB_FOCUS=true
  SYSTEM_FOCUS=true
  CVE_FOCUS=true
fi

# Script execution start time
START_TIME=$(date +%s)

# Display banner
print_banner

# Run dependency checks
check_dependencies

# Always gather system information first
gather_system_info

# Run selected scans
if $SYSTEM_FOCUS || $FULL_SCAN; then
  check_hardware
fi

if $CVE_FOCUS || $FULL_SCAN; then
  check_cves
fi

if $WEB_FOCUS || $FULL_SCAN; then
  check_web_vulnerabilities
fi

# Calculate execution time
END_TIME=$(date +%s)
EXECUTION_TIME=$((END_TIME - START_TIME))

# Display summary
print_section "Scan Summary"
print_info "Scan completed in $EXECUTION_TIME seconds"

# Cleanup temporary files
if $DO_CLEANUP; then
  cleanup
else
  print_info "Temporary files were not removed as requested"
  print_info "Temporary files location: /tmp/*_$$.tmp"
fi

echo -e "\n${BOLD}${GREEN}Scan completed successfully!${NC}"

